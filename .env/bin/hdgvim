#!/usr/bin/env python3

# ─ Copyright Notice ───────────────────────────────────────────────────
#
# Copyright 2000-2023 Hans Deragon - GPL 3.0 licence.
#
# Hans Deragon (hans@deragon.biz) owns the copyright of this work.
#
# It is released under the GPL 3 licence which can be found at:
#
#     https://www.gnu.org/licenses/gpl-3.0.en.html
#
# ─────────────────────────────────────────────────── Copyright Notice ─

import os
import sys
import shutil
import subprocess
import platform

description="""
This script is used to call gvim, if available, or vim otherwise.  Under
Windows, the proper gvim.exe will be called with any file passed as an
argument converted to Windows format so gvim.exe can find it.
"""

vimType = "gvim"

if "--hdgvim" in sys.argv:
    sys.argv.remove("--hdgvim")
    vimType = "gvim"
if "--hdvim" in sys.argv:
    sys.argv.remove("--hdvim")
    vimType = "vim"
if "--hddiff" in sys.argv:
    vimType += "diff"
    sys.argv.remove("--hddiff")

try:
    gvim_from_env = [ os.environ['HD_GVIM'] ]
except:
    # OS environment variable HD_GVIM is not set, thus we set it to None so
    # the test for this non-existent binary will not be executed.
    gvim_from_env = []

try:
    display = os.environ['DISPLAY']
    if display == "":
        display = None
except:
    display = None

if display is None or vimType == "vim":
    # If there is no DISPLAY, then there is no point in calling gVim.
    gvim     = []
    gvimdiff = []
    gvim_from_env = []
else:
    gvim     = [ "gvim"    , "gvim.exe" ]
    gvimdiff = [ "gvimdiff", "gvimdiff.exe" ]

vim      = [ "vim",      "vim.exe"  ]
vimdiff  = [ "vimdiff",  "vimdiff.exe"  ]

if "diff" in vimType or ( len(gvim_from_env) > 0 and "diff" in gvim_from_env[0] ):
    vim_to_try = gvim_from_env + gvimdiff + vimdiff
else:
    vim_to_try = gvim_from_env + gvim + vim

#print(f"vim_to_try = {vim_to_try}")
for binary in vim_to_try:
    executable = shutil.which(binary)
    if executable is not None:
        break

if executable is None:
    print("ERROR:  Could not find [g]vim.  Aborting")
    sys.exit(1)

nominalArgs  = []

hdvimrc     = os.environ['HDVIMRC']
hdvimrcpost = os.environ['HDVIMRC'] + "-post"

if os.path.isfile(hdvimrc) and os.access(hdvimrc, os.R_OK):
  nominalArgs  += [ "-u", hdvimrc]
if os.path.isfile(hdvimrcpost) and os.access(hdvimrcpost, os.R_OK):
  nominalArgs  += [ "-S", hdvimrcpost]

nominalArgs += sys.argv[1:]

if "cygwin" in platform.system().lower() and "gvim" in executable.lower():
    # Windows Gvim being used here.

    # ${HDVIM} is in Cygwin path format, but gvim.exe is not a Cygwin
    # binary and requires a Windows format path.  Thus, we are converting
    # it here.  Remember, ${HDVIM} is used in .vimrc!
    completedProcess = subprocess.run(
            ["cygpath", "-w", os.environ['HDVIM']],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    os.environ['HDVIM']=completedProcess.stdout.decode('utf-8').rstrip()

    # When ${TZ} is set to "America/Toronto", the 'strftime' function of
    # gVim will return the wrong "ric" timezone.  So we hardcode ${TZ}
    # here to EDT assuming we are always in EDT and the problem is solved.
    os.environ['TZ']="EDT"

    # Test each argument passed to the command to see if it is a file.  If
    # it is, convert the path format from Cygwin format to Windows format.
    tmpArgs = []
    for arg in nominalArgs:
        if arg[0] != '-' and os.path.isfile(arg):
            completedProcess = subprocess.run(
                    ["cygpath", "-w", arg],
                    stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            tmpArgs.append(completedProcess.stdout.decode("utf-8").rstrip())
        else:
            tmpArgs.append(arg)
    nominalArgs = tmpArgs

#print("nominalArgs:  " + str(nominalArgs))
#print("argv:  " + str(argv))
finalArgs = nominalArgs
cmd = [ executable ] + finalArgs
#print("cmd:  " + str(cmd))
#print("cmd:  " + str(" ".join(cmd)))

if "gvim" in executable.lower() and display != None:

    # Forking here to allow user to go back to the terminal prompt quickly.
    # Sometimes, gvim takes time to start, for instance when the DISPLAY
    # environment variable is not properly set and gvim waits long before
    # timing out and returning to the prompt.
    if os.fork() != 0:
        # Parent process must die, to un-hook the terminal.
        sys.exit(0)

# See:  https://docs.python.org/3/library/os.html#process-management
os.execvp(executable, cmd)
