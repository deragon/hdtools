#!/usr/bin/env python3

# ─ Copyright Notice ───────────────────────────────────────────────────
#
# Copyright 2000-2024 Hans Deragon - AGPL 3.0 licence.
#
# Hans Deragon (hans@deragon.biz) owns the copyright of this work.  It is
# released under the GNU Affero General public Picense which can be found at:
#
#     https://www.gnu.org/licenses/agpl-3.0.en.html
#
# ─────────────────────────────────────────────────── Copyright Notice ─

import boto3
import os.path
import sys
import logging

from datetime import datetime
import time

import argparse

# os.path.realpath(os.curdir) # Current directory, canonical form.

scriptName=os.path.basename(sys.argv[0])
scriptPath=os.path.dirname(sys.argv[0])

scriptPathAbs=os.path.realpath(scriptPath)
scriptPathAbsParent=os.path.dirname(scriptPathAbs)

scriptNameAndPathAbs=scriptPathAbs + os.sep + scriptName

iso8601Human    = "%Y-%m-%d %H:%M:%S"
iso8601Filename = "%Y%m%dT%H%M%S"

try:
    scriptNameBase=scriptName.rsplit('.', 1)[0] # Extension found.
except IndexError:
    scriptNameBase=scriptName # There is no extension.

ansi = {
    "FG_WHITE_BG_GREEN":      "\033[1;37;42m",
    "FG_BLACK_BG_YELLOW":     "\033[1;30;43m",
    "FG_WHITE_BG_RED":        "\033[1;37;41m",
    "FG_WHITE_BG_BLUE":       "\033[1;37;44m",
    "FG_WHITE_BG_ORANGERED":  "\033[38;2;255;255;255m\033[48;2;255;69;0m",  # Requires True Colors (24 bits) terminal.
    "RESET":                  "\033[0;00m",
    "BOLD":                   "\033[1m",
    "ITALIC":                 "\033[2m",
    "UNDERLINE":              "\033[3m",
    "REVERSE":                "\033[7m",
    "STRIKETHROUGH":          "\033[9m",
    "BOLD_OFF":               "\033[21m",
    "ITALIC_OFF":             "\033[22m",
    "UNDERLINE_OFF":          "\033[23m",
    "REVERSE_OFF":            "\033[27m",
    "STRIKETHROUGH_OFF":      "\033[29m",
    "BLACK":                  "\033[30m",
    "RED":                    "\033[31m",
    "GREEN":                  "\033[32m",
    "YELLOW":                 "\033[33m",
    "BLUE":                   "\033[34m",
    "MAGENTA":                "\033[35m",
    "CYAN":                   "\033[36m",
    "WHITE":                  "\033[37m",
    "BG_RED":                 "\033[41m",
    "BG_GREEN":               "\033[42m",
    "BG_YELLOW":              "\033[43m",
    "BG_BLUE":                "\033[44m",
    "BG_MAGENTA":             "\033[45m",
    "BG_CYAN":                "\033[46m",
    "BG_WHITE":               "\033[47m",
    "BG_DEFAULT":             "\033[49m"
}

# PARSING ARGUMENTS
# ────────────────────────────────────────────────────────────────────────────
#
# See:  https://docs.python.org/3/library/argparse.html
#
# WARNING:
#
# - and -- options are always optional according to argparse.  If you
# want mandatory arguments, they should not be prefixed with - or --.
#
# http://stackoverflow.com/questions/24180527/argparse-required-arguments-listed-under-optional-arguments

parser = argparse.ArgumentParser(description=f"""
{ansi['FG_WHITE_BG_RED']} DANGER {ansi['RESET']}

Completely empty a S3, including all versions of objects to the point where
the S3 can be then delete.

Example:

    """ + scriptName + """  bucketname1 [bucketname2]+

""", formatter_class=argparse.RawTextHelpFormatter)

# Positional arguments.
# If <files> is mandatory, use "nargs='+'".  If optional, use "nargs='*'".
parser.add_argument('buckets', metavar='buckets', type=str, nargs='+',
        help='Name of buckets to delete.  Not ARN or s3://, only the name of the buckets.')

# Mandatory arguments.
# parser.add_argument('-d', '--dst', dest='dst', default='.', required=True,
#                     help='Destination where subdirectories will be created.')

# Optional arguments.
# action="store_true" means is that if the argument is given on the command
# line then a True value should be stored in the parser.
# parser.add_argument('--hardlink', dest='hardlink',
#                     default=False, action="store_true",
#                     help='Create hard links instead of moving files.')
#
# parser.add_argument('-s', '--split', dest='split', default=10, required=False,
#                     help='Number of split to perform.')

# Optional argument with parameter (--user USER).  By putting 'type=str', we
# tell the parser that the argument must take a parameter with it.
# parser.add_argument('-u', '--user', type=str, dest='user',
#                     default=os.environ["USER"], help='Provide user id.')

# Optional argument with choices.
# See:  https://stackoverflow.com/questions/40324356/python-argparse-choices-with-a-default-choice
# parser.add_argument('-t', '--type', dest='type', default="ascii7bits", required=False, type=str,
#                     nargs='?',
#                     choices=['ascii7bits', 'latin', 'digitAndLetters', 'digitAndLowerLetters', 'digitAndUpperLetters' ],
#                     help='Length of password generated.  Default is ascii7bits.')

parser.add_argument('-l', '--log-level', dest='loglevel', default='info',
       choices=['debug', 'info', 'warning', 'error', 'critical'],
       help='Set logs level.  Default is \'info\'.')
#       help='Niveau des logs.  Défaut est \'info\'.')

args = parser.parse_args()

if args.loglevel=="debug":
    level=logging.DEBUG
elif args.loglevel=="warning":
    level=logging.WARNING
elif args.loglevel=="error":
    level=logging.ERROR
elif args.loglevel=="critical":
    level=logging.CRITICAL
else:
    level=logging.INFO


# When setting the log level with logging.basicConfig(), the log level is set
# for ALL Python modules that using the logging facility, not just the code
# found in this script.  This is usually not desired.
#
# It is preferred to use a logger and set the log level only for it, so only
# its logs are showing, not that of other modules (very preferable when the
# log level is set to DEBUG).

# logging.debug("Test of logging %s", "here. :)")
logging.basicConfig(
    format='%(asctime)s - %(levelname)5s - %(funcName)20s(): %(message)s',
    datefmt=iso8601Human)

# Creating a logger with the script's name and setting it to a specific log
# level.
logger = logging.getLogger(scriptName)
logger.setLevel(level)
logger.debug("Test of logging %s", "here. :)")


errors = ""

# if args.hardlink == True:
#   errors += "\n  --hardlink is required."

def report_error():

    if len(errors) > 0:
        print(f"{ansi['FG_WHITE_BG_RED']}ERROR:{ansi['RESET']}  The following errors where detected.\n" + errors + "\n\nCommand aborted.")
        print(f"{ansi['FG_WHITE_BG_RED']}ERREUR:{ansi['RESET']}  Les erreurs suivantes furent détectées.\n" + errors + "\n\nCommande avortée")
        sys.exit(1)

report_error()


#print(args)

#print("Subdirectories will be created in '" + args.dst + "'.")


# PROCESSING
# ══════════════════════════════════════════════════════════════════════════════

def delete_all_objects(bucket_name):
    s3 = boto3.resource('s3')
    bucket = s3.Bucket(bucket_name)
    bucket.objects.all().delete()

def delete_all_versions(bucket_name):
    s3 = boto3.resource('s3')
    bucket = s3.Bucket(bucket_name)
    bucket.object_versions.delete()

def empty_s3_bucket(bucket_name):
    delete_all_objects(bucket_name)
    delete_all_versions(bucket_name)


def main():

    for bucket in args.buckets:
        print(f"Deleting objects of:  {bucket}")
        empty_s3_bucket(bucket)


if __name__ == "__main__":
    main()
