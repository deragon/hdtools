#!/usr/bin/env python3

# ─ Copyright Notice ───────────────────────────────────────────────────
#
# Copyright 2000-2022 Hans Deragon - GPL 3.0 licence.
#
# Hans Deragon (hans@deragon.biz) owns the copyright of this work.
#
# It is released under the GPL 3 licence which can be found at:
#
#     https://www.gnu.org/licenses/gpl-3.0.en.html
#
# ─────────────────────────────────────────────────── Copyright Notice ─

import os.path
import sys
import logging
import random

from datetime import datetime

import argparse
from argparse import RawTextHelpFormatter

# os.path.realpath(os.curdir) # Current directory, canonical form.


scriptPath=os.path.dirname(sys.argv[0])
scriptName=os.path.basename(sys.argv[0])

logger = logging.getLogger(scriptName)

scriptPathAbs=os.path.realpath(scriptPath)
scriptPathAbsParent=os.path.dirname(scriptPathAbs)

scriptNameAndPathAbs=scriptPathAbs + os.sep + scriptName

try:
  scriptNameBase=scriptName.rsplit('.', 1)[0] # Extension found.
except IndexError:
  scriptNameBase=scriptName # There is no extension.



# PARSING ARGUMENTS
# ────────────────────────────────────────────────────────────────────────────
#
# See:  http://docs.python.org/2/library/argparse.html
#
# WARNING:
#
# - and -- options are always optional according to argparse.  If you
# want mandatory arguments, they should not be prefixed with - or --.
#
# http://stackoverflow.com/questions/24180527/argparse-required-arguments-listed-under-optional-arguments


# This piece of code allow the translation of automatic english messages
# generated by argparse into french.
#
# From:  https://stackoverflow.com/questions/22951442/how-to-make-pythons-argparse-generate-non-english-text
def convertArgparseMessages(s):
    subDict = \
    {'positional arguments':'Arguments positionnels',
    'optional arguments':'Arguments optionnels',
    'show this help message and exit':'Affiche ce message et quitte'}
    if s in subDict:
        s = subDict[s]
    return s
import gettext
gettext.gettext = convertArgparseMessages

#gettext.translation('guess', localedir='locale', languages=['fr']).install()


parser = argparse.ArgumentParser(description="""
Generates a password based on a preselected set of acceptable caracters.
""", formatter_class=RawTextHelpFormatter)

# parser.add_argument('hdfs_dir', nargs='+', type=str, help='Répertoire dans HDFS dans lequel la concaténation sera faite.  par exemple:  "/user/hive/somedir"')
#
# # Positional arguments definition here.
# parser.add_argument('inputdir', metavar='<input directory>',
#                     type=str,  nargs='+', help='Input directory.')
#
# parser.add_argument('files', metavar='files', type=str, nargs='+',
#                     help='List of files to rename.')
# parser.add_argument('-d' '--dst', dest='dst', default='.', required=True,
#                     help='Destination where subdirectories will be created.')
# parser.add_argument('--hardlink', dest='hardlink',
#                     default=False, action="store_true",
#                     help='Create hard links instead of moving files.')
# parser.add_argument('--softlink', dest='softlink',
#                     default=False, action="store_true",
#                     help='Create soft links instead of moving files.')
# parser.add_argument('-s', '--split', dest='split', default=10, required=False,
#                     help='Number of split to perform.')

parser.add_argument('-d', '--debug', dest='debug', default=False, action="store_true", help='Debug level logs enabled.')
parser.add_argument('-i', '--info' , dest='info' , default=False, action="store_true", help='Info level logs enabled.')
parser.add_argument('-e', '--error', dest='error', default=False, action="store_true", help='Error level logs enabled.')

args = parser.parse_args()

if args.debug == True:
  logging.basicConfig(level=logging.DEBUG)
elif args.info == True:
  logging.basicConfig(level=logging.INFO)
elif args.error == True:
  logging.basicConfig(level=logging.ERROR)
else:
  logging.basicConfig(level=logging.WARNING)

errors=""

# if args.hardlink == True and args.softlink == True:
#   errors += "\n  --hardlink and --softlink are mutually exclusive.  You must chose one."
#
if len(errors) > 0:
  print("\x1B[1;37;41mERROR:\x1B[0m  The following errors where detected.\n" + errors + "\n\nCommand aborted.")
  print("\x1B[1;37;41mERREUR:\x1B[0m  Les erreurs suivantes furent détectées.\n" + errors + "\n\nCommande avortée")
  sys.exit(1)

# From https://stackoverflow.com/questions/1477294/generate-random-utf-8-string-in-python
def get_random_unicode(length):

    try:
        get_char = unichr
    except NameError:
        get_char = chr

    # Update this to include code point ranges to be sampled
    set11 = [
        ( 0x0021, 0x0021 ),
        ( 0x0023, 0x0026 ),
        ( 0x0028, 0x007E ),
        ( 0x00A1, 0x00AC ),
        ( 0x00AE, 0x00FF ),
        ( 0x0100, 0x017F ),
        ( 0x0180, 0x024F ),
        ( 0x2C60, 0x2C7F ),
        ( 0x16A0, 0x16F0 ),
        ( 0x0370, 0x0377 ),
        ( 0x037A, 0x037E ),
        ( 0x0384, 0x038A ),
        ( 0x038C, 0x038C ),
    ]

    ascii7bits = [
        ( 0x0021, 0x007E ),
    ]

    include_ranges = set11
    include_ranges = ascii7bits

    caracterset = [
        get_char(code_point) for current_range in include_ranges
            for code_point in range(current_range[0], current_range[1] + 1)
    ]

    logger.debug("caracterset=%s", str(caracterset))
    return ''.join(random.choice(caracterset) for i in range(length))

if __name__ == '__main__':
    print(get_random_unicode(32))
