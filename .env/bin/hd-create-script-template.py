#!/usr/bin/env python

# ─ Copyright Notice ───────────────────────────────────────────────────
#
# Copyright 2000-2025 Hans Deragon - AGPL 3.0 licence.
#
# Hans Deragon (hans@deragon.biz) owns the copyright of this work.  It is
# released under the GNU Affero General Public License which can be found at:
#
#     https://www.gnu.org/licenses/agpl-3.0.en.html
#
# ─────────────────────────────────────────────────── Copyright Notice ─

"""
Template script for Python projects.
"""

import argparse
import getpass
import json
import logging
import os
import pathlib
import re
import shutil
import socket
import subprocess
import sys
import time
import traceback
from configparser import SafeConfigParser
from datetime import datetime
from email.mime.text import MIMEText
from smtplib import SMTP

import yaml  # Requires: pip install pyyaml

# Constants
ISO8601_HUMAN = "%Y-%m-%d %H:%M:%S"
ISO8601_FILENAME = "%Y%m%dT%H%M%S"

# fmt: off
ANSI = {
    "FG_WHITE_BG_GREEN":      "\033[1;37;42m",
    "FG_BLACK_BG_YELLOW":     "\033[1;30;43m",
    "FG_WHITE_BG_RED":        "\033[1;37;41m",
    "FG_WHITE_BG_BLUE":       "\033[1;37;44m",
    "FG_WHITE_BG_ORANGERED":  "\033[38;2;255;255;255m\033[48;2;255;69;0m",  # Requires True Colors (24 bits) terminal.
    "RESET":                  "\033[0;00m",
    "BOLD":                   "\033[1m",
    "ITALIC":                 "\033[2m",
    "UNDERLINE":              "\033[3m",
    "REVERSE":                "\033[7m",
    "STRIKETHROUGH":          "\033[9m",
    "BOLD_OFF":               "\033[21m",
    "ITALIC_OFF":             "\033[22m",
    "UNDERLINE_OFF":          "\033[23m",
    "REVERSE_OFF":            "\033[27m",
    "STRIKETHROUGH_OFF":      "\033[29m",
    "BLACK":                  "\033[30m",
    "RED":                    "\033[31m",
    "GREEN":                  "\033[32m",
    "YELLOW":                 "\033[33m",
    "BLUE":                   "\033[34m",
    "MAGENTA":                "\033[35m",
    "CYAN":                   "\033[36m",
    "WHITE":                  "\033[37m",
    "BG_RED":                 "\033[41m",
    "BG_GREEN":               "\033[42m",
    "BG_YELLOW":              "\033[43m",
    "BG_BLUE":                "\033[44m",
    "BG_MAGENTA":             "\033[45m",
    "BG_CYAN":                "\033[46m",
    "BG_WHITE":               "\033[47m",
    "BG_DEFAULT":             "\033[49m"
}
# fmt: on

# Global variables for script info
SCRIPT_NAME = os.path.basename(sys.argv[0])
SCRIPT_PATH = os.path.dirname(sys.argv[0])
SCRIPT_PATH_ABS = os.path.realpath(SCRIPT_PATH)
SCRIPT_PATH_ABS_PARENT = os.path.dirname(SCRIPT_PATH_ABS)
SCRIPT_NAME_AND_PATH_ABS = os.path.join(SCRIPT_PATH_ABS, SCRIPT_NAME)

try:
    SCRIPT_NAME_BASE = SCRIPT_NAME.rsplit('.', 1)[0]  # Extension found.
except IndexError:
    SCRIPT_NAME_BASE = SCRIPT_NAME  # There is no extension.


def setup_logging(log_level_str):
    """Configures the logging."""
    if log_level_str == "debug":
        level = logging.DEBUG
    elif log_level_str == "warning":
        level = logging.WARNING
    elif log_level_str == "error":
        level = logging.ERROR
    elif log_level_str == "critical":
        level = logging.CRITICAL
    else:
        level = logging.INFO

    # When setting the log level with logging.basicConfig(), the log level and
    # other parameters are set for ALL Python modules that using the logging
    # facility, not just the code found in this script.  This is usually not
    # desired.
    #
    # logging.basicConfig(
    # 	level=logging.DEBUG,
    #     format='%(asctime)s - %(levelname)5s - %(funcName)20s(): %(message)s',
    #     datefmt=ISO8601_HUMAN,
    #     # filename=f"/var/log/{SCRIPT_NAME}.log",
    #     # filemode="a",
    #     )

    formatter = logging.Formatter(
        "%(asctime)s - %(levelname)5s - %(funcName)20s(): %(message)s",
        datefmt=ISO8601_HUMAN
    )

    # Handler for STDOUT
    sh = logging.StreamHandler()
    sh.setLevel(level)
    sh.setFormatter(formatter)

    # Handler for log file.
    log_filename = f"{SCRIPT_NAME_AND_PATH_ABS}-{datetime.now().strftime(ISO8601_FILENAME)}.log"
    fh = logging.FileHandler(log_filename, mode='a')
    fh.setLevel(level)
    fh.setFormatter(formatter)

    # Creating a logger
    logger_instance = logging.getLogger(SCRIPT_NAME)
    logger_instance.setLevel(level)
    logger_instance.addHandler(sh)
    logger_instance.addHandler(fh)
    return logger_instance


# WARNING:  THIS GETTEXT CODE DOES NOT WORKANYMORE WITH PYTHON 3.
#
#           See: https://stackoverflow.com/questions/35347168/python-3-gettext-not-working-for-argparse
#
#
# This piece of code allow the translation of automatic english messages
# generated by argparse into french.
#
# From:  https://stackoverflow.com/questions/22951442/how-to-make-pythons-argparse-generate-non-english-text
# def convertArgparseMessages(s):
#     subDict = {
#         'positional arguments':             'Arguments positionnels',
#         'optional arguments':               'Arguments optionnels',
#         'show this help message and exit':  'Affiche ce message d\'aide et quitte'
#     }
#     if s in subDict:
#         s = subDict[s]
#     return s
# import gettext
# gettext.gettext = convertArgparseMessages
# gettext.translation('guess', localedir='locale', languages=['fr']).install()


def parse_arguments():
    """Parses command line arguments."""
    parser = argparse.ArgumentParser(description=f"""
{ANSI['FG_WHITE_BG_GREEN']} SAFE {ANSI['RESET']}
{ANSI['FG_BLACK_BG_YELLOW']} SLIGHT DANGER {ANSI['RESET']}
{ANSI['FG_WHITE_BG_RED']} DANGER {ANSI['RESET']}

{ANSI['FG_WHITE_BG_GREEN']} SAUF {ANSI['RESET']}
{ANSI['FG_BLACK_BG_YELLOW']} LÉGER DANGER {ANSI['RESET']}
{ANSI['FG_WHITE_BG_RED']} DANGER {ANSI['RESET']}

Read a .ini file and export its full content in variables that Bash can make use of.

For example, run:

    {SCRIPT_NAME}  config.ini --export

""", formatter_class=argparse.RawTextHelpFormatter)

    # Positional arguments.
    # If <files> is mandatory, use "nargs='+'".  If optional, use "nargs='*'".
    parser.add_argument('files', metavar='files', type=str, nargs='+',
                        help='List of files to rename.')

    # Mandatory arguments.
    # parser.add_argument('-d', '--dst', dest='dst', default='.', required=True,
    #                     help='Destination where subdirectories will be created.  Default:  %(default)s"')

    # Optional arguments.
    # action="store_true" means is that if the argument is given on the command
    # line then a True value should be stored in the parser.
    # parser.add_argument('--hardlink', dest='hardlink',
    #                     default=False, action="store_true",
    #                     help='Create hard links instead of moving files.')
    #
    # parser.add_argument('-s', '--split', dest='split', default=10, required=False,
    #                     help='Number of split to perform.')

    # Optional argument with parameter (--user USER).  By putting 'type=str', we
    # tell the parser that the argument must take a parameter with it.
    # parser.add_argument('-u', '--user', type=str, dest='user',
    #                     default=os.environ["USER"], help='Provide user id.')

    # Optional argument with choices.
    # See:  https://stackoverflow.com/questions/40324356/python-argparse-choices-with-a-default-choice
    # parser.add_argument('-t', '--type', dest='type', default="ascii7bits", required=False, type=str,
    #                     nargs='?',
    #                     choices=['ascii7bits', 'latin', 'digitAndLetters', 'digitAndLowerLetters', 'digitAndUpperLetters' ],
    #                     help='Length of password generated.  Default is ascii7bits.')

    parser.add_argument('-l', '--log-level', dest='loglevel', default='info',
                        choices=['debug', 'info', 'warning', 'error', 'critical'],
                        help="Set logs level. Default is 'info'.")

    return parser.parse_args()


def report_error(errors):
    """Reports errors and exits if any."""
    if len(errors) > 0:
        print(f"{ANSI['FG_WHITE_BG_RED']}ERROR:{ANSI['RESET']}  The following errors where detected.\n" + errors + "\n\nCommand aborted.")
        print(f"{ANSI['FG_WHITE_BG_RED']}ERREUR:{ANSI['RESET']}  Les erreurs suivantes furent détectées.\n" + errors + "\n\nCommande avortée")
        sys.exit(1)


def file_commands_examples():
    """Examples of file commands."""
    # rm -rf:  Erase directory, causes no error if not existing.
    # shutil.rmtree(path, ignore_errors=True, onerror=None)

    # mkdir -p:  from Python >= 3.5
    # pathlib.Path("<directory name/path here>").mkdir(parents=True, exist_ok=True)

    # shutil.copy2(package, packages_dir) # cp -p (best copy option)
    # os.chdir("<dir>")  # cd "<dir">

    # 'mkdir -p' - OLD CODE (Python 2)?
    # import errno
    # try:
    #   os.makedirs(args.dst + os.sep + str(index) )
    # except OSError as oserror:
    #   if oserror.errno == errno.EEXIST:
    #     pass   # Already exists, we continue.
    #
    #     import shutil  # Erase directory recursively and recreate it.
    #     shutil.rmtree(directory)
    #     os.makedirs(directory)
    #   else:
    #     raise  # Some odd problem, maybe permission problem?  Raising.
    pass


def regex_example(line):
    """Example of regex usage."""
    pattern = re.compile(r"<regex>")
    matches = pattern.match(line)
    if matches is not None:
        data = matches.group(1)
        return data
    return None


def read_write_file_examples(file, filename, output):
    """Examples of reading and writing files."""
    lines = [ i.strip() for i in open("somefile") ]  # Strips lines

    # All in memory
    whole_content = open(file).read()
    lines = open(file).readlines()  # Lines remain intact.

    for line in lines:
        pass

    # Not all in memory, one line at a time
    lines = open(file)

    for line in lines:
        pass

    with open(filename,'w+') as fd:  # '+' means create if it does not exist.
                                     # 'a' stands for append.
        fd.write(output + "\n")  # Because of 'with', fd will be closed automatically.
    pass


def json_example():
    """Example of JSON usage."""
    with open('file.json') as fd:
        json_dict = json.load(fd)

    json_dict = json.loads('{ "test": "Hi there." }')  # Load json from str.
    json_string = json.dumps(json_dict, ensure_ascii=False, indent=2)
    return json_string


def linux_conf_dir():
    """Return Linux standard configuration directory for a user."""
    try:
        config_dir = os.environ["XDG_CONFIG_HOME"]
    except KeyError:
        config_dir = os.path.join(os.environ["HOME"], ".config")
    return config_dir


def yaml_example(logger):
    """Example of YAML usage."""
    config_path = os.path.join(linux_conf_dir(), "myproject", "myfile.yaml")

    with open(config_path, 'r') as stream:
        print(f"Reading configuration file:  {config_path}")
        yaml_conf = yaml.safe_load(stream)
    
    logger.debug(f"yaml_conf = {yaml_conf}")
    return yaml_conf
    pass


def string_to_hex(string):
    """Converts a string to hex representation."""
    return ':'.join("{:0>2}".format(hex(ord(x))[2:]) for x in string).upper()


def debugging_example():
    """Example of debugging."""
    # Using Stop watch module to measure laps time between calls.
    # See:  https://pypi.org/project/swpy/

    # from swpy import Timer
    #
    # t = Timer("Chronometer")
    #
    # t.split()
    # <long function here
    # t.split()
    pass


def curses_example():
    """Example of curses usage."""
    # Snippet to print over a line the index we are at.
    # import curses
    # setupterm()
    # index=1000
    # print(title, end="")
    # indexpos=len(title)+10
    # For...
    #    print("\r" + curses.tparm(curses.tigetstr("cuf"), indexpos, 0).decode("UTF8") + str(index), end="")
    pass


def walk_directory_example(args):
    """Example of walking a directory."""
    # files = [os.path.join(dirpath, filename) for (dirpath, dirs, files) in os.walk('.') for filename in (dirs + files)]
    # files = [path for path in pathlib.Path(".").rglob("*.txt")]  # Return all '*.txt' files; Global search support.
    # Returns all directories which contains files with extension "*.tf".
    # directories = sorted(set([path.parent for path in pathlib.Path(".").rglob("*.tf")]))  # Global search support.

    # WARNING:
    #
    # This script is far from perfect.  It makes use of os.walk that reads in
    # memory all the files.  Thus if you have say 30E06 files, this script will
    # consume Gib of memories.
    #
    # One should use os.scandir() for large directories.
    # See:  https://peps.python.org/pep-0471/
    
    # index = 0
    # for root, dirs, files in os.walk(args.inputdir):
    #     # print "root="  + str(root)
    #     # print "dirs="  + str(dirs)
    #     # print "files=" + str(files)
    #
    #     numberoffiles = len(files)
    #
    #     for file in files:
    #         # basename=os.path.basename(file)
    #
    #         # from pathlib import Path
    #         # https://docs.python.org/3/library/pathlib.html
    #         # basename_without_extension=Path(basename).stem
    #         # extension=Path(basename).suffix
    #         # extensions=Path(basename).suffixes  # Return an array, such as PurePosixPath('my/library.tar.gz').suffixes returns ['.tar', '.gz']
    #
    #         index += 1
    #         dst_fullpath = args.dst + os.sep + str(index % args.split) + os.sep + file
    #         src_fullpath = root + os.sep + file
    #
    #         print("                                                                                \r", end=' ')
    #
    #         if index % 100000 == 0:
    #             print("Number of entries processed " + str(index))  # + "\n\n"
    #
    #         if args.hardlink:
    #             print("Creating hardlink " + src_fullpath + " -> " + dst_fullpath, end=' ')
    #             os.link(src_fullpath, dst_fullpath)
    #         elif args.softlink:
    #             print("Creating softlink " + src_fullpath + " -> " + dst_fullpath, end=' ')
    #             os.symlink(src_fullpath, dst_fullpath)
    #         else:
    #             print("Moving " + src_fullpath + " -> " + dst_fullpath, end=' ')
    #             os.rename(src_fullpath, dst_fullpath)
    #         print("\r", end=' ')
    pass


def handle_exception(exception):
    """Handles exceptions by sending an email."""
    logging.error("Exception lancée:  %s", str(exception))

    username = getpass.getuser()
    hostname = socket.gethostname()

    config = SafeConfigParser()
    config.read(os.path.join(os.environ["HOME"], "config", "lake.ini"))
    try:
        emails = config['Support']['emails'].split(' ')
        env = config['Environment']['type']
    except KeyError:
        logging.error("Could not read config for email support.")
        return

    # Sending an email when an error occured.
    body = "En " + env + """, l'erreur suivante:

  """ + str(exception) + """
  """ + '  '.join(('\n' + traceback.format_exc().lstrip()).splitlines(True)) + """
...c'est produite à l'exécution du script:

  """ + username + "@" + hostname + ":" + SCRIPT_NAME_AND_PATH_ABS

    logging.error("Contenu du courriel d'erreur suit:\n\n%s", body)

    msg = MIMEText(body, 'plain')
    msg['Subject'] = env + " / partition - Erreur sur " + username + "@" + hostname + ":  " + str(exception)
    msg['To'] = ','.join(emails)

    conn = SMTP("localhost")
    conn.set_debuglevel(False)
    try:
        conn.sendmail("noreply@videotron.com", emails, msg.as_string())
    finally:
        conn.quit()


def run_os_command(command_as_array: list[str], logger) -> tuple[int, str, str]:
    """Runs an OS command."""
    logger.debug("Executing:  " + " ".join(command_as_array))
    completed_process = subprocess.run(command_as_array, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout = completed_process.stdout.decode('utf-8').rstrip()
    stderr = completed_process.stderr.decode('utf-8').rstrip()

    logger.debug(f"stdout  = >>{stdout}<<")
    logger.debug(f"stderr  = >>{stderr}<<")
    logger.debug(f"retcode = >>{completed_process.returncode}<<")

    return completed_process.returncode, stdout, stderr


def main():
    """Main function."""
    args = parse_arguments()
    logger = setup_logging(args.loglevel)

    # PARAMETERS VALIDATIONS
    errors = ""
    # if args.hardlink:
    #     errors += "\n  --hardlink is required."
    report_error(errors)

    # Example usage of run_os_command
    # (returncode, stdout, stderr) = run_os_command(["cat", "/etc/services"], logger)

    # READ AND WRITE TO A FILES OR STDIN
    if len(args.files) == 0:
        args.files = ["<stdin>"]

    for file_path in args.files:
        text = None
        if "<stdin>" in file_path:
            fd = sys.stdin
            text = "".join(fd.readlines())
        else:
            if os.path.exists(file_path):
                with open(file_path) as fd:
                    text = "".join(fd.readlines())
            else:
                logger.warning(f"File not found: {file_path}")
                continue

        if text:
            pattern = re.compile(r"^\s+Name:\s+(\w+).*$", re.MULTILINE)
            for matches in pattern.finditer(text):
                data = matches.group(1)
                logger.info(">>" + str(data) + "<<")


def main_wrapper():
    """Wrapper for main to handle exceptions and timing."""
    # noinspection PyBroadException
    try:
        time_start = datetime.now()

        main()

        time_end = datetime.now()

        time_executed = time_end - time_start
        time_executed_hours, time_executed_remainder = divmod(time_executed.seconds, 3600)
        time_executed_minutes, time_executed_seconds = divmod(time_executed_remainder, 60)

        time_start_string = time_start.strftime(ISO8601_HUMAN)
        time_end_string = time_end.strftime(ISO8601_HUMAN)

        print("\nStarted:   " + time_start_string)
        print("Ended:     " + time_end_string)
        print("Executed:  {0:02}:{1:02}:{2:02}".format(time_executed_hours, time_executed_minutes, time_executed_seconds))

        print("\nDébuté:     " + time_start_string)
        print("Terminé:    " + time_end_string)
        print("Exécution:  {0:02}:{1:02}:{2:02}".format(
            time_executed_hours, time_executed_minutes, time_executed_seconds))

    except Exception as exception:
        # We need a logger here, but it might not be initialized if exception happens early.
        # We'll try to get it or use basic logging.
        logger = logging.getLogger(SCRIPT_NAME)
        if not logger.handlers:
             logging.basicConfig(level=logging.ERROR)
             logger = logging.getLogger(SCRIPT_NAME)

        logger.error("Exception:  %s", exception)
        stacktrace = traceback.format_exc()
        logger.error("Exception:  %s", stacktrace)
        handle_exception(exception)


if __name__ == "__main__":
    main_wrapper()
