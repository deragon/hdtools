#!/usr/bin/env python3

# ─ Copyright Notice ───────────────────────────────────────────────────
#
# Copyright 2000-2025 Hans Deragon - AGPL 3.0 licence.
#
# Hans Deragon (hans@deragon.biz) owns the copyright of this work.  It is
# released under the GNU Affero General Public License which can be found at:
#
#     https://www.gnu.org/licenses/agpl-3.0.en.html
#
# ─────────────────────────────────────────────────── Copyright Notice ─

import os.path
import sys
import logging
from datetime import datetime
import argparse

import secrets
from base64 import urlsafe_b64encode as b64e, urlsafe_b64decode as b64d

from cryptography.fernet import Fernet
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

from cryptography.fernet import InvalidToken

# os.path.realpath(os.curdir) # Current directory, canonical form.

scriptName=os.path.basename(sys.argv[0])
scriptPath=os.path.dirname(sys.argv[0])

scriptPathAbs=os.path.realpath(scriptPath)
scriptPathAbsParent=os.path.dirname(scriptPathAbs)

scriptNameAndPathAbs=scriptPathAbs + os.sep + scriptName

try:
  scriptNameBase=scriptName.rsplit('.', 1)[0] # Extension found.
except IndexError:
  scriptNameBase=scriptName # There is no extension.

# PARSING ARGUMENTS
# ────────────────────────────────────────────────────────────────────────────
#
# See:  https://docs.python.org/3/library/argparse.html
#
# WARNING:
#
# - and -- options are always optional according to argparse.  If you
# want mandatory arguments, they should not be prefixed with - or --.
#
# http://stackoverflow.com/questions/24180527/argparse-required-arguments-listed-under-optional-arguments


# This piece of code allow the translation of automatic english messages
# generated by argparse into french.
#
# From:  https://stackoverflow.com/questions/22951442/how-to-make-pythons-argparse-generate-non-english-text
# def convertArgparseMessages(s):
#     subDict = \
#     {'positional arguments':'Arguments positionnels',
#     'optional arguments':'Arguments optionnels',
#     'show this help message and exit':'Affiche ce message et quitte'}
#     if s in subDict:
#         s = subDict[s]
#     return s
# import gettext
# gettext.gettext = convertArgparseMessages
# gettext.translation('guess', localedir='locale', languages=['fr']).install()


parser = argparse.ArgumentParser(description="""

Given a string, encryps or decrypts it with a password provided with STDIN.

For example, run:

    """ + scriptName + """ -s "This is a string" -e

    Then, when asked, enter a password.  Lets use 'hello' for this example.  To decrypt:

Pq8AVbie3iqPz-XAwNsBaQAAAECAAAAAAGBYpjOoptIzXuIyvSlNdn2YIl_iaoOF3HP-0ZKlSlnrgBX3dQCVPRNqEAFjQcGZJSG4eB991UPY5SJ9Cz9sdmOOTojzYJdexD9W5DYoV2SR064f-w==

    """ + scriptName + """ -s "Pq8AVbie3iqPz-XAwNsBaQAAAECAAAAAAGBYpjOoptIzXuIyvSlNdn2YIl_iaoOF3HP-0ZKlSlnrgBX3dQCVPRNqEAFjQcGZJSG4eB991UPY5SJ9Cz9sdmOOTojzYJdexD9W5DYoV2SR064f-w==" -d

    ...and enter 'hello' again.  The following will show up:

    This is a string
""", formatter_class=argparse.RawTextHelpFormatter)

# Positional arguments.
# parser.add_argument('files', metavar='files', type=str, nargs='+',
#                     help='Strings to encode/decode')

# Mandatory arguments.
# parser.add_argument('-d' '--dst', dest='dst', default='.', required=True,
#                     help='Destination where subdirectories will be created.')

# Optional arguments.
# action="store_true" means is that if the argument is given on the command
# line then a True value should be stored in the parser.
# parser.add_argument('--hardlink', dest='hardlink',
#                     default=False, action="store_true",
#                     help='Create hard links instead of moving files.')
#
# parser.add_argument('-p', '--password', dest='password', required=True,
#                     help='Password to encrypt with.')

parser.add_argument('-s', '--string', dest='string', required=True,
                    help='String encode or decode (must be base64 to decode).')

group = parser.add_mutually_exclusive_group(required=True)
group.add_argument('-e', '--encode', dest='encode', action="store_true")
group.add_argument('-d', '--decode', dest='encode', action="store_false")

# Optional argument with parameter (--user USER).  By putting 'type=str', we
# tell the parser that the argument must take a parameter with it.
# parser.add_argument('-u', '--user', type=str, dest='user',
#                     default=os.environ["USER"], help='Provide user id.')

parser.add_argument('-l', '--log-level', dest='loglevel', default='info',
       choices=['debug', 'info', 'warning', 'error', 'critical'],
       help='Debug level logs enabled.')

args = parser.parse_args()

if args.loglevel=="debug":
    logging.basicConfig(level=logging.DEBUG)
elif args.loglevel=="warning":
    logging.basicConfig(level=logging.WARNING)
elif args.loglevel=="error":
    logging.basicConfig(level=logging.ERROR)
elif args.loglevel=="critical":
    logging.basicConfig(level=logging.CRITICAL)
else:
    logging.basicConfig(level=logging.INFO)

errors=""

# if args.hardlink == True:
#   errors += "\n  --hardlink is required."

if len(errors) > 0:
    print("\x1B[1;37;41mERROR:\x1B[0m  The following errors where detected.\n" + errors + "\n\nCommand aborted.")
    sys.exit(1)

#print(args)


# logging.debug("Test of logging %s", "here. :)")
#
# logger = logging.getLogger(scriptName)
# logger.debug("Test of logging %s", "here. :)")



# READ AND WRITE TO A FILE
# ────────────────────────────────────────────────────────────────────────────
#
# lines = [ i.strip() for i in open("somefile") ]  # Strips lines
#
# # All in memory
# lines = open(file).readlines()  # Lines remain intact.
#
# for line in lines:
#   pass
#
# # Not all in memory, one line at a time
# lines = open(file)
#
# for line in lines:
#   pass
#
# fileOutput = open(filename + ".new" ,'w+')  # '+' means create if does not exists.  'a' is for append.
# fileOutput.write(output + "\n")
# fileOutput.close()



# Encryption functions
# ════════════════════════════════════════════════════════════════════
#
#   From:  https://stackoverflow.com/questions/2490334/simple-way-to-encode-a-string-according-to-a-password

backend = default_backend()
iterations = 64

def _derive_key(password: bytes, salt: bytes, iterations: int = iterations) -> bytes:
    """Derive a secret key from a given password and salt"""
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(), length=32, salt=salt,
        iterations=iterations, backend=backend)
    return b64e(kdf.derive(password))

def password_encrypt(message: bytes, password: str, iterations: int = iterations) -> bytes:
    salt = secrets.token_bytes(16)
    key = _derive_key(password.encode(), salt, iterations)
    return b64e(
        b'%b%b%b' % (
            salt,
            iterations.to_bytes(4, 'big'),
            b64d(Fernet(key).encrypt(message)),
        )
    )

def password_decrypt(token: bytes, password: str) -> bytes:
    decoded = b64d(token)
    salt, iter, token = decoded[:16], decoded[16:20], b64e(decoded[20:])
    iterations = int.from_bytes(iter, 'big')
    key = _derive_key(password.encode(), salt, iterations)
    return Fernet(key).decrypt(token)



# MAIN
# ════════════════════════════════════════════════════════════════════
password = input("Enter password:  ")

message = None

if args.string:
    message = args.string.encode()

if args.encode:
    output = password_encrypt(message, password).decode('UTF-8')
else:
    try:
        output = password_decrypt(message, password).decode('UTF-8')
    except InvalidToken:
        print("\x1B[1;37;41mERROR:\x1B[0m  Wrong password provided.")
        sys.exit(2)

print(output)

